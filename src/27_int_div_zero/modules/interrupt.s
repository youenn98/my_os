;************************************************************************
;中断向量的初始化
;************************************************************************
ALIGN 4
IDTR:	dw 		8 * 256 - 1					; idt_limit
		dd 		VECT_BASE					; idt location

;************************************************************************
;中断table的初始化
;************************************************************************
init_int:
		push	eax
		push	ebx
		push	ecx
		push	edi

		;---------------------------------------
		; 所有的中断表的初始化
		;---------------------------------------
		lea		eax, [int_default]				; EAX   = 中断处理的地址;
		mov		ebx, 0x0008_8E00				; EBX   = segment selector -> code segment;
		xchg	ax, bx							; // 低位的word交换

		mov		ecx, 256						; ECX   =	中断向量的个数
		mov		edi, VECT_BASE					; EDI   =   中断向量表

.10L:											; do
												; {
		mov		[edi + 0], ebx					;   [EDI + 0] = 中断描述符(低位)
		mov		[edi + 4], eax					;   [EDI + 4] = 中断描述符(高位)
		add		edi, 8							;   EDI += 8;
		loop	.10L							; } while (ECX--);

		;---------------------------------------
		; 中断描述符的设定
		;---------------------------------------
		lidt	[IDTR]							; // 加载中断描述符

		pop		edi
		pop		ecx
		pop		ebx
		pop		eax

		ret



;************************************************************************
;表示stack的值
;************************************************************************
int_stop:
		;---------------------------------------
		; EAX表示的字符串
		;---------------------------------------
		cdecl	draw_str, 25, 15, 0x060F, eax	; draw_str(EAX);

		;---------------------------------------
		; 将stack_data转换成字符串
		;---------------------------------------
		mov		eax, [esp + 0]					; EAX = ESP[ 0];
		cdecl	itoa, eax, .p1, 8, 16, 0b0100	; itoa(EAX, 8, 16, 0b0100);

		mov		eax, [esp + 4]					; EAX = ESP[ 4];
		cdecl	itoa, eax, .p2, 8, 16, 0b0100	; itoa(EAX, 8, 16, 0b0100);

		mov		eax, [esp + 8]					; EAX = ESP[ 8];
		cdecl	itoa, eax, .p3, 8, 16, 0b0100	; itoa(EAX, 8, 16, 0b0100);

		mov		eax, [esp +12]					; EAX = ESP[12];
		cdecl	itoa, eax, .p4, 8, 16, 0b0100	; itoa(EAX, 8, 16, 0b0100);

		;---------------------------------------
		; 字符串打印
		;---------------------------------------
		cdecl	draw_str, 25, 16, 0x0F04, .s1	; draw_str("ESP+ 0:-------- ");
		cdecl	draw_str, 25, 17, 0x0F04, .s2	; draw_str("   + 4:-------- ");
		cdecl	draw_str, 25, 18, 0x0F04, .s3	; draw_str("   + 8:-------- ");
		cdecl	draw_str, 25, 19, 0x0F04, .s4	; draw_str("   +12:-------- ");

		;---------------------------------------
		; 无限循环
		;---------------------------------------
		jmp		$								; while (1) ; // 无限循环

.s1		db	"ESP+ 0:"
.p1		db	"________ ", 0
.s2		db	"   + 4:"
.p2		db	"________ ", 0
.s3		db	"   + 8:"
.p3		db	"________ ", 0
.s4		db	"   +12:"
.p4		db	"________ ", 0

;*************************
;default中断
;*************************
int_default:
		pushf									; // EFLAGS(IF==0)
		push	cs								; // CS
		push	int_stop						; // 表示stack

		mov		eax, .s0						; // 中断的类别
		iret

.s0		db	" <    STOP    > ", 0

;***********************
;除0中断
;***********************
int_zero_div:
	pushf		;//EFLAGS
	push cs		;//cs
	push int_stop		;//显示stack

	mov eax,.s0			;//中断的类别
	iret

.s0 db"< ZERO DIV >",0